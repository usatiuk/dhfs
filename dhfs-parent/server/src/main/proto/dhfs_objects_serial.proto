syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.usatiuk.dhfs.objects.persistence";
option java_outer_classname = "DhfsObjectPersistence";

package dhfs.objects.persistence;

message ObjectMetadataP {
  string name = 1;
  map<string, int64> remoteCopies = 2;
  string knownClass = 3;
  bool seen = 4;
  bool deleted = 5;
  repeated string confirmedDeletes = 6;
  repeated string referrers = 7;
  map<string, int64> changelog = 8;
  repeated string savedRefs = 9;
  bool locked = 10;
  bool haveLocalCopy = 11;
}

message FsNodeP {
  string uuid = 1;
  int64 mode = 2;
  int64 ctime = 3;
  int64 mtime = 4;
}

message FileP {
  FsNodeP fsNode = 1;
  map<int64, string> chunks = 2;
  bool symlink = 3;
}

message DirectoryP {
  FsNodeP fsNode = 1;
  map<string, string> children = 2;
}

message ChunkInfoP {
  string name = 1;
  int32 size = 2;
}

message ChunkDataP {
  string name = 1;
  bytes data = 2;
}

message PeerDirectoryP {
  repeated string peers = 1;
}

message PersistentPeerInfoP {
  string uuid = 1;
  bytes cert = 2;
}

message TreeNodeMetaFileP {
  string name = 1;
  string fileMirror = 2;
}

message TreeNodeMetaDirectoryP {
  string name = 1;
}

message TreeNodeP {
  optional string parent = 1;
  string id = 2;
  map<string, string> children = 3;
  oneof meta {
    TreeNodeMetaFileP file = 4;
    TreeNodeMetaDirectoryP dir = 5;
  }
}

message JObjectDataP {
  oneof obj {
    FileP file = 2;
    DirectoryP directory = 3;
    ChunkInfoP chunkInfo = 4;
    ChunkDataP chunkData = 5;
    PeerDirectoryP peerDirectory = 6;
    PersistentPeerInfoP persistentPeerInfo = 7;
    TreeNodeP treeNode = 8;
  }
}